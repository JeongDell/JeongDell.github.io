---
layout: post
title:  "파이썬 데이터분석 실무 테크닉 10"
published: true
date:   2024-10-08 05:50:00
categories: DA(Data Analytics)
permalink: /DAP/3_2
---

# 물류 네트워크 최적 설계를 위한 테크닉 10

![image](https://github.com/user-attachments/assets/b361b558-22ce-4daf-8283-5b44ac696cef)

- 기본적인 물류 네트워크 구조

## 운송 최적화 문제 풀기

- product(a,b): a의 각 요소와 b의 각 요소를 조합한 튜플(수정 불가) 생성
- model_min(): 최소화 문제 정의를 위한 모델 객체 생성
- LpVariable: PuLP에서 선형 계획법 모델에 사용할 변수를 정의
- v%d_%d'%(i,j): 변수 이름에(i,j)의 값을 포함하기 위해 문자열 포매팅을 사용
- v%d_%d: i,j 값을 문자열 안에 삽입하여 고유한 변수 이름 생성(1,0)이면 v0_1 변수를 생성




```python
import numpy as np
import pandas as pd
from itertools import product
#최적화 모델 작성
from pulp import LpVariable, lpSum, value
# 목적함수 생성 후 최적홤 문제 해결
from ortoolpy import model_min, addvars, addvals

# 데이터 불러오기
df_tc = pd.read_csv('trans_cost.csv', index_col="공장")
df_demand = pd.read_csv('demand.csv')
df_supply = pd.read_csv('supply.csv')


 # 초기 설정  #
np.random.seed(1)
# 행 개수
nw = len(df_tc.index)
# 열 개수
nf = len(df_tc.columns)
# (공급지, 수요지) 쌍 리스트
pr = list(product(range(nw), range(nf)))

# 수리 모델 작성

m1 = model_min()

#lowBound=0: 최솟값을 0으로 지정하여 변수가 음수가 되지 않도록 설정
# 각 운송 경로별 운송량 변수 정의
v1 = {(i,j):LpVariable('v%d_%d'%(i,j),lowBound=0) for i,j in pr}

#각 운송 경로의 비용 * 운송량 변수의 합을 계산(lp.cum:행렬의 곱 계산용용)
m1 += lpSum(df_tc.iloc[i][j]*v1[i,j] for i,j in pr)
#공급 제약 조건: 각 공깁지 i에서 총 운송량이 공급량(df_supply.iloc[0][i]))을 초과하지 않도록 함
for i in range(nw):
    m1 += lpSum(v1[i,j] for j in range(nf)) <= df_supply.iloc[0][i]
#수요 제약 조건: 각 수요지 j에서의 총 운송량이 수요량(df_demand.iloc[0][j]) 이상이 되도록 설정
for j in range(nf):
    m1 += lpSum(v1[i,j] for i in range(nw)) >= df_demand.iloc[0][j]


#모델 해 구함
m1.solve()


# 최적 해를 적용하여 총 운송 비용 계산#
df_tr_sol = df_tc.copy()
total_cost = 0
for k,x in v1.items():
    i,j = k[0],k[1]
    df_tr_sol.iloc[i][j] = value(x)
    total_cost += df_tc.iloc[i][j]*value(x)
    
print(df_tr_sol)
print("총 운송 비용:"+str(total_cost))
```
![image](https://github.com/user-attachments/assets/99f1d9be-b9b7-4aac-b82b-05a1afa11a3a)


## 최적 운송 경로를 네트워크로 확인 

```python

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

df_tr = df_tr_sol.copy()
df_pos = pd.read_csv('trans_route_pos.csv')


# 객체 생성
G = nx.Graph()

# 노드 설정
for i in range(len(df_pos.columns)):
    #df_pos의 각 열 이름을 노드 이름으로 사용
    G.add_node(df_pos.columns[i])

# 엣지 설정 & 엣지의 가중치 리스트화
#엣지의 수 추적 변수
num_pre = 0
#각 엣지의 가중치 정보 저장
edge_weights = []
#가중치 조정 계수
size = 0.1
for i in range(len(df_pos.columns)):
    for j in range(len(df_pos.columns)):
        if not (i==j):
            # 엣지 추가
            G.add_edge(df_pos.columns[i],df_pos.columns[j])
            # 엣지 가중치 추가
            if num_pre<len(G.edges):
                num_pre = len(G.edges)
                weight = 0
                if (df_pos.columns[i] in df_tr.columns)and(df_pos.columns[j] in df_tr.index):
                    if df_tr[df_pos.columns[i]][df_pos.columns[j]]:
                        weight = df_tr[df_pos.columns[i]][df_pos.columns[j]]*size
                elif(df_pos.columns[j] in df_tr.columns)and(df_pos.columns[i] in df_tr.index):
                    if df_tr[df_pos.columns[j]][df_pos.columns[i]]:
                        weight = df_tr[df_pos.columns[j]][df_pos.columns[i]]*size
                edge_weights.append(weight)
                

# 좌표 설정
pos = {}
for i in range(len(df_pos.columns)):
    node = df_pos.columns[i]
    pos[node] = (df_pos[node][0],df_pos[node][1])
    
# 그리기
nx.draw(G, pos, with_labels=True,font_size=16, node_size = 1000, node_color='k', font_color='w', width=edge_weights)

# 표시
plt.show()
```
![image](https://github.com/user-attachments/assets/0fdeab2d-3e7b-453f-a080-82da99dd9ad8)

>W1에서 F1DMFG, W2에서 F3로, W3에서 F2,F4로의 공급이 대분, 나머지는 최소화    

> 운송 경로는 어느정도 집중돼야 한다가 참임을 알 수 있음

## 최적 운송 경로가 제약조건을 만족하는지 확인

```python
df_demand = pd.read_csv('demand.csv')
df_supply = pd.read_csv('supply.csv')

# 제약조건 계산함수
# 수요측
def condition_demand(df_tr,df_demand):
    flag = np.zeros(len(df_demand.columns))
    for i in range(len(df_demand.columns)):
        temp_sum = sum(df_tr[df_demand.columns[i]])
        if (temp_sum>=df_demand.iloc[0][i]):
            flag[i] = 1
    return flag
            
# 공급측
def condition_supply(df_tr,df_supply):
    flag = np.zeros(len(df_supply.columns))
    for i in range(len(df_supply.columns)):
        temp_sum = sum(df_tr.loc[df_supply.columns[i]])
        if temp_sum<=df_supply.iloc[0][i]:
            flag[i] = 1
    return flag

print("수요 조건 계산 결과:"+str(condition_demand(df_tr_sol,df_demand)))
print("공급 조건 계산 결과:"+str(condition_supply(df_tr_sol,df_supply)))

수요 조건 계산 결과:[1. 1. 1. 1.]
공급 조건 계산 결과:[1. 1. 1.]
```

> 수요쪽, 공급 쪽 모두 제약조건을 만족하고 있음을 알 수 있음   

>운송 최적화 처럼 선형 최적화로 장식화할 수 있는 것은 짧은 시간에 정답을 구할 수 있음

## 생산계획 데이터 불러오기

- 물류 네트워크는 운송과 생산 계획 모두 중요

```python
df_material = pd.read_csv('product_plan_material.csv', index_col="제품")

df_profit = pd.read_csv('product_plan_profit.csv', index_col="제품")

df_stock = pd.read_csv('product_plan_stock.csv', index_col="항목")

df_plan = pd.read_csv('product_plan.csv', index_col="제품")
```

## 이익 계산함수 생성

```python
# 이익 계산 함수 (이익*게획량)
def product_plan(df_profit,df_plan):
    profit = 0
    for i in range(len(df_profit.index)):
        for j in range(len(df_plan.columns)):
            profit += df_profit.iloc[i][j]*df_plan.iloc[i][j]
    return profit

print("총 이익:"+str(product_plan(df_profit,df_plan)))

총 이익:80.0
```

## 생산 최적화 문제 해결

```python
from pulp import LpVariable, lpSum, value
from ortoolpy import model_max, addvars, addvals


df = df_material.copy()
inv = df_stock

#최대화 계산 준비
m = model_max()
#v1을 제품 수와 같은 차원으로 정의
v1 = {(i):LpVariable('v%d'%(i),lowBound=0) for i in range(len(df_profit))}
#v1과 제품별 이익의 곱의 합으로 목적함수 정의
m += lpSum(df_profit.iloc[i]*v1[i] for i in range(len(df_profit)))
#제약조건 정의(각 원료의 사용량<제약 조건)
for i in range(len(df_material.columns)):
    m += lpSum(df_material.iloc[j,i]*v1[j] for j in range(len(df_profit)) ) <= df_stock.iloc[:,i]
m.solve()

df_plan_sol = df_plan.copy()
for k,x in v1.items():
    df_plan_sol.iloc[k] = value(x)
print(df_plan_sol)
print("총 이익:"+str(value(m.objective)))

     생산량
제품      
제품1   15
제품2    5
총 이익:95.0
```

> 제품 1의 생샨량을 줄이고 제품2의 생산량을 늘려서 총이익이 증가함을 알 수 있음

## 최적 생산 계획이 제약 조건을 만족하는지 확인

- 목적함수와 제약조건이 현실과 달라 계산된 결과도 현실과 안 맞는 경우가 발생
   -  따라서 최적화 계싼 결과를 여러 가지 방법을 이용해서 이해할 필요가 있음
 
```python
# 제약 조건 계산 함수
def condition_stock(df_plan,df_material,df_stock):
    #0으로 가득찬 array 생성
    flag = np.zeros(len(df_material.columns))
    for i in range(len(df_material.columns)):  
        temp_sum = 0
        for j in range(len(df_material.index)):  
            temp_sum = temp_sum + df_material.iloc[j][i]*float(df_plan.iloc[j])
        if (temp_sum<=float(df_stock.iloc[0][i])):
            flag[i] = 1
        print(df_material.columns[i]+"  사용량:"+str(temp_sum)+", 재고:"+str(float(df_stock.iloc[0][i])))
    return flag

print("제약 조건 계산 결과:"+str(condition_stock(df_plan_sol,df_material,df_stock)))

원료1  사용량:25.0, 재고:40.0
원료2  사용량:80.0, 재고:80.0
원료3  사용량:50.0, 재고:50.0
제약 조건 계산 결과:[1. 1. 1.]
```

> 원료1,2,3을 최대한 사용하면서 제약조건을 충족했기 때문에 원료의 사용효율이 크게 개선된 것을 알 수 있음

> 즉 최적화가 잘 되었음

## 물류 네트워크 설계 문제 해결

```python

#목적 함수: 운송비용과 제조 비용의 합
#제약조건: 각 대리점의 판매 수가 수요 수를 넘는 것
#list('ab'): a,b를 각 인자로 받음, 즉 ['a'.'b']가 됨
제품 = list('AB')
대리점 = list('PQ')
공장 = list('XY')
레인 = (2,2)

# 운송비 
tbdi = pd.DataFrame(((j,k) for j in 대리점 for k in 공장), columns=['대리점','공장'])
#tdbi의 열 개수와 일치할 것
tbdi['운송비'] = [1,2,3,1]
print(tbdi)

# 수요 
tbde = pd.DataFrame(((j,i) for j in 대리점 for i in 제품), columns=['대리점','제품'])
tbde['수요'] = [10,10,20,20]
print(tbde)

# 생산 
#공장, 레인, 제품이라는 세 개의 리스트를 사용하여 DataFrame을 생성
#np.inf: numpy에서 양의 무한대를 나타냄, 초기값으로 무한히 큰 값을 설정
#zip(공장,레인): 공장과 레인 리스트의 각 요소를 쌍을 묶음
#공장: [A,B]이고 레인:[1,2]면 zip(공장,레인): [(A,1),(B,2)]
#첫 번째 for문(for k, nl in zip(공장, 레인)) 공장과 레인 리스트의 요소를 하나씩 묶어 가져옴. 예를 들어, 공장이 [A, B], 레인이 [2, 3]이라면 첫 반복에서 (k, nl)는 (A, 2)가 되고, 다음에는 (B, 3)이 됨
tbfa = pd.DataFrame(((k,l,i,0,np.inf) for k,nl in zip (공장,레인) for l in range(nl) for i in 제품), 
                    columns=['공장','레인','제품','하한','상한'])
tbfa['생산비'] = [1,np.nan,np.nan,1,3,np.nan,5,3]
tbfa.dropna(inplace=True)
tbfa.loc[4,'상한']=10
print(tbfa)

from ortoolpy import logistics_network
_, tbdi2, _ = logistics_network(tbde, tbdi, tbfa,dep = "대리점", dem = "수요",fac = "공장",
                                prd = "제품",tcs = "운송비",pcs = "생산비",lwb = "하한",upb = "상한")

print(tbfa)
print(tbdi2)

대리점 공장  운송비
0   P  X    1
1   P  Y    2
2   Q  X    3
3   Q  Y    1

  대리점 제품  수요
0   P  A  10
1   P  B  10
2   Q  A  20
3   Q  B  20

  공장  레인 제품  하한    상한  생산비
0  X   0  A   0   inf  1.0
3  X   1  B   0   inf  1.0
4  Y   0  A   0  10.0  3.0
6  Y   1  A   0   inf  5.0
7  Y   1  B   0   inf  3.0

  공장 레인 제품  하한  상한  생산비     VarY  ValY
0  X   0   A     0    inf   1.0   v000009  20.0
3  X   1   B     0    inf   1.0   v000010  10.0
4  Y   0   A     0   10.0   3.0   v000011  10.0
6  Y   1   A     0    inf   5.0   v000012   0.0
7  Y   1   B     0    inf   3.0   v000013  20.0

  대리점 공장  운송비  제품  VarX  ValX
0   P    X     1     A  v000001  10.0
1   P    X     1     B  v000002  10.0
2   P    Y     2     A  v000003   0.0
3   P    Y     2     B  v000004   0.0
4   Q    X     3     A  v000005  10.0
5   Q    X     3     B  v000006   0.0
6   Q    Y     1     A  v000007  10.0
7   Q    Y     1     B  v000008  20.0

```


## 최적 네트워크의 운송 비용과 그 내역 계산

- 운송비용 = 운송비 * 최적 운송량

```python
tbdi2 = tbdi2[["공장","대리점","운송비","제품","VarX","ValX"]]

trans_cost = 0
for i in range(len(tbdi2.index)):
    trans_cost += tbdi2["운송비"].iloc[i]*tbdi2["ValX"].iloc[i]
print("총 운송비:"+str(trans_cost))

총 운송비:80.0
```

## 최적 네트워크의 생산 비용과 그 내역 계산

```pyhton
product_cost = 0
for i in range(len(tbfa.index)):
    product_cost += tbfa["생산비"].iloc[i]*tbfa["ValY"].iloc[i]
print("총 생산비:"+str(product_cost))

총 생산비:120.0
```
